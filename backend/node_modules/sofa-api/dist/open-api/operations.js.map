{"version":3,"file":"operations.js","sourceRoot":"","sources":["../../src/open-api/operations.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  DocumentNode,\n  GraphQLSchema,\n  VariableDefinitionNode,\n  TypeNode,\n  OperationDefinitionNode,\n  ObjectTypeDefinitionNode,\n  FieldNode,\n  parse,\n  printType,\n} from 'graphql';\n\nimport { getOperationInfo } from '../ast';\nimport { mapToPrimitive, mapToRef } from './utils';\nimport { resolveFieldType } from './types';\nimport titleCase = require('title-case');\n\nexport function buildPathFromOperation({\n  url,\n  schema,\n  operation,\n  useRequestBody,\n}: {\n  url: string;\n  schema: GraphQLSchema;\n  operation: DocumentNode;\n  useRequestBody: boolean;\n}): any {\n  const info = getOperationInfo(operation)!;\n\n  const description = resolveDescription(schema, info.operation);\n\n  return {\n    operationId: info.name,\n    ...(useRequestBody\n      ? {\n          requestBody: {\n            content: {\n              'application/json': {\n                schema: resolveRequestBody(info.operation.variableDefinitions),\n              },\n            },\n          },\n        }\n      : {\n          parameters: resolveParameters(\n            url,\n            info.operation.variableDefinitions\n          ),\n        }),\n    responses: {\n      200: {\n        description,\n        content: {\n          'application/json': {\n            schema: resolveResponse({\n              schema,\n              operation: info.operation,\n            }),\n          },\n        },\n      },\n    },\n  };\n}\n\nfunction resolveParameters(\n  url: string,\n  variables: ReadonlyArray<VariableDefinitionNode> | undefined\n) {\n  if (!variables) {\n    return [];\n  }\n\n  return variables.map((variable: any) => {\n    return {\n      in: isInPath(url, variable.variable.name.value) ? 'path' : 'query',\n      name: variable.variable.name.value,\n      required: variable.type.kind === 'NonNullType',\n      schema: resolveParamSchema(variable.type),\n    };\n  });\n}\n\nfunction resolveRequestBody(\n  variables: ReadonlyArray<VariableDefinitionNode> | undefined\n) {\n  if (!variables) {\n    return {};\n  }\n\n  const properties: Record<string, any> = {};\n  const required: string[] = [];\n\n  variables.forEach(variable => {\n    if (variable.type.kind === 'NonNullType') {\n      required.push(variable.variable.name.value);\n    }\n\n    properties[variable.variable.name.value] = resolveParamSchema(\n      variable.type\n    );\n  });\n\n  return {\n    type: 'object',\n    properties,\n    ...(required.length ? { required } : {}),\n  };\n}\n\n// array -> [type]\n// type -> $ref\n// scalar -> swagger primitive\nfunction resolveParamSchema(type: TypeNode): any {\n  if (type.kind === 'NonNullType') {\n    return resolveParamSchema(type.type);\n  }\n\n  if (type.kind === 'ListType') {\n    return {\n      type: 'array',\n      items: resolveParamSchema(type.type),\n    };\n  }\n\n  const primitive = mapToPrimitive(type.name.value);\n\n  return (\n    primitive || {\n      $ref: mapToRef(type.name.value),\n    }\n  );\n}\n\nfunction resolveResponse({\n  schema,\n  operation,\n}: {\n  schema: GraphQLSchema;\n  operation: OperationDefinitionNode;\n}) {\n  const operationType = operation.operation;\n  const rootField = operation.selectionSet.selections[0];\n\n  if (rootField.kind === 'Field') {\n    if (operationType === 'query') {\n      const queryType = schema.getQueryType()!;\n      const field = queryType.getFields()[rootField.name.value];\n\n      return resolveFieldType(field.type);\n    }\n\n    if (operationType === 'mutation') {\n      const mutationType = schema.getMutationType()!;\n      const field = mutationType.getFields()[rootField.name.value];\n\n      return resolveFieldType(field.type);\n    }\n  }\n}\n\nfunction isInPath(url: string, param: string): boolean {\n  return url.indexOf(`{${param}}`) !== -1;\n}\n\nfunction resolveDescription(\n  schema: GraphQLSchema,\n  operation: OperationDefinitionNode\n) {\n  const selection = operation.selectionSet.selections[0] as FieldNode;\n  const fieldName = selection.name.value;\n  const typeDefinition = schema.getType(titleCase(operation.operation));\n\n  if (!typeDefinition) {\n    return '';\n  }\n\n  const definitionNode =\n    typeDefinition.astNode || parse(printType(typeDefinition)).definitions[0];\n\n  if (!isObjectTypeDefinitionNode(definitionNode)) {\n    return '';\n  }\n\n  const fieldNode = definitionNode.fields!.find(\n    field => field.name.value === fieldName\n  );\n  const descriptionDefinition = fieldNode && fieldNode.description;\n  return descriptionDefinition && descriptionDefinition.value\n    ? descriptionDefinition.value\n    : '';\n}\n\nfunction isObjectTypeDefinitionNode(\n  node: any\n): node is ObjectTypeDefinitionNode {\n  return node.kind === 'ObjectTypeDefinition';\n}\n"]}