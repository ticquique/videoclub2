{"version":3,"file":"sofa.js","sourceRoot":"","sources":["../src/sofa.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  GraphQLSchema,\n  graphql,\n  isObjectType,\n  GraphQLObjectType,\n  getNamedType,\n  GraphQLNamedType,\n  isListType,\n  isNonNullType,\n  GraphQLOutputType,\n} from 'graphql';\n\nimport {\n  Ignore,\n  Context,\n  ContextFn,\n  ExecuteFn,\n  OnRoute,\n  MethodMap,\n} from './types';\nimport { convertName } from './common';\nimport { logger } from './logger';\nimport { ErrorHandler } from './express';\n\n// user passes:\n// - schema\n// - error handler\n// - execute function\n// - context\n\nexport interface SofaConfig {\n  schema: GraphQLSchema;\n  context?: Context;\n  execute?: ExecuteFn;\n  /**\n   * Treats an Object with an ID as not a model.\n   * @example [\"User\", \"Message.author\"]\n   */\n  ignore?: Ignore;\n  onRoute?: OnRoute;\n  depthLimit?: number;\n  errorHandler?: ErrorHandler;\n  /**\n   * Overwrites the default HTTP method.\n   * @example {\"Query.field\": \"GET\", \"Mutation.field\": \"POST\"}\n   */\n  method?: MethodMap;\n}\n\nexport interface Sofa {\n  schema: GraphQLSchema;\n  context: Context;\n  models: string[];\n  ignore: Ignore;\n  method?: MethodMap;\n  execute: ExecuteFn;\n  onRoute?: OnRoute;\n  errorHandler?: ErrorHandler;\n}\n\nexport function createSofa(config: SofaConfig): Sofa {\n  logger.debug('[Sofa] Created');\n\n  const models = extractsModels(config.schema);\n  const ignore = config.ignore || [];\n\n  logger.debug(`[Sofa] models: ${models.join(', ')}`);\n  logger.debug(`[Sofa] ignore: ${ignore.join(', ')}`);\n\n  return {\n    context({ req }) {\n      return { req };\n    },\n    execute: graphql,\n    models,\n    ignore,\n    ...config,\n  };\n}\n\n// Objects and Unions are the only things that are used to define return types\n// and both might contain an ID\n// We don't treat Unions as models because\n// they might represent an Object that is not a model\n// We check it later, when an operation is being built\nfunction extractsModels(schema: GraphQLSchema): string[] {\n  const modelMap: {\n    [name: string]: {\n      list?: boolean;\n      single?: boolean;\n    };\n  } = {};\n  const query = schema.getQueryType()!;\n  const fields = query.getFields();\n\n  // if Query[type] (no args) and Query[type](just id as an argument)\n\n  // loop through every field\n  for (const fieldName in fields) {\n    const field = fields[fieldName];\n    const namedType = getNamedType(field.type);\n\n    if (hasID(namedType)) {\n      if (!modelMap[namedType.name]) {\n        modelMap[namedType.name] = {};\n      }\n\n      if (isArrayOf(field.type, namedType)) {\n        // check if type is a list\n        // check if name of a field matches a name of a named type (in plural)\n        // check if has no non-optional arguments\n        // add to registry with `list: true`\n        const sameName = isNameEqual(field.name, namedType.name + 's');\n        const allOptionalArguments = !field.args.some(arg =>\n          isNonNullType(arg.type)\n        );\n\n        modelMap[namedType.name].list = sameName && allOptionalArguments;\n      } else if (\n        isObjectType(field.type) ||\n        (isNonNullType(field.type) && isObjectType(field.type.ofType))\n      ) {\n        // check if type is a graphql object type\n        // check if name of a field matches with name of an object type\n        // check if has only one argument named `id`\n        // add to registry with `single: true`\n        const sameName = isNameEqual(field.name, namedType.name);\n        const hasIdArgument =\n          field.args.length === 1 && field.args[0].name === 'id';\n\n        modelMap[namedType.name].single = sameName && hasIdArgument;\n      }\n    }\n  }\n\n  return Object.keys(modelMap).filter(\n    name => modelMap[name].list && modelMap[name].single\n  );\n}\n\n// it's dumb but let's leave it for now\nfunction isArrayOf(\n  type: GraphQLOutputType,\n  expected: GraphQLObjectType\n): boolean {\n  if (isOptionalList(type)) {\n    return true;\n  }\n\n  if (isNonNullType(type) && isOptionalList(type.ofType)) {\n    return true;\n  }\n\n  function isOptionalList(list: GraphQLOutputType) {\n    if (isListType(list)) {\n      if (list.ofType.name === expected.name) {\n        return true;\n      }\n\n      if (\n        isNonNullType(list.ofType) &&\n        list.ofType.ofType.name === expected.name\n      ) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction hasID(type: GraphQLNamedType): type is GraphQLObjectType {\n  return isObjectType(type) && !!type.getFields().id;\n}\n\nfunction isNameEqual(a: string, b: string): boolean {\n  return convertName(a) === convertName(b);\n}\n\nexport function isContextFn(context: any): context is ContextFn {\n  return typeof context === 'function';\n}\n"]}